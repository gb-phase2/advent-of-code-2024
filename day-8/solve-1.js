import clipboard from "clipboardy";
import fs from "fs";

export const input = fs
  .readFileSync("input.txt", "utf8")
  .replaceAll("\r", "")
  .split("\n");

/**
 * Parses the input lines into a 2D character grid.
 * @param {string[]} inputLines - An array of strings representing each row of the puzzle map.
 * @returns {string[][]} A 2D array of characters where grid[r][c] is a character from the input.
 */
export const parseGrid = (inputLines) =>
  inputLines.map((line) => line.split(""));

/**
 * Finds all antennas on the grid and groups them by their frequency character.
 * @param {string[][]} grid - The puzzle grid as a 2D array of characters.
 * @returns {Object.<string, number[][]>} An object keyed by frequency character.
 * Each value is an array of [row, col] coordinates where that antenna frequency is found.
 */
export const findAntennasByFrequency = (grid) => {
  const antennasByFreq = {};
  const rows = grid.length;
  const cols = grid[0].length;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const ch = grid[r][c];

      if (ch !== ".") {
        if (!antennasByFreq[ch]) {
          antennasByFreq[ch] = [];
        }

        antennasByFreq[ch].push([r, c]);
      }
    }
  }

  return antennasByFreq;
};

/**
 * Given two antenna coordinates, computes the two antinode positions.
 * @param {number} Ax - Row coordinate of the first antenna.
 * @param {number} Ay - Column coordinate of the first antenna.
 * @param {number} Bx - Row coordinate of the second antenna.
 * @param {number} By - Column coordinate of the second antenna.
 * @returns {number[][]} An array containing two sets of coordinates: [[P1x, P1y], [P2x, P2y]].
 */
const computeAntinodePositions = (Ax, Ay, Bx, By) => {
  const P1x = 2 * Ax - Bx;
  const P1y = 2 * Ay - By;
  const P2x = 2 * Bx - Ax;
  const P2y = 2 * By - Ay;

  return [
    [P1x, P1y],
    [P2x, P2y],
  ];
};

/**
 * Checks if a given position is within the bounds of the grid.
 * @param {number} x - The row coordinate.
 * @param {number} y - The column coordinate.
 * @param {number} rows - Total number of rows in the grid.
 * @param {number} cols - Total number of columns in the grid.
 * @returns {boolean} True if (x,y) lies within the grid boundaries, otherwise false.
 */
export const isWithinBounds = (x, y, rows, cols) =>
  x >= 0 && x < rows && y >= 0 && y < cols;

/**
 * Calculates all unique antinodes generated by antennas of the same frequency.
 * @param {Object.<string, number[][]>} antennasByFreq - Object mapping frequencies to arrays of antenna coordinates.
 * @param {number} rows - Total number of rows in the grid.
 * @param {number} cols - Total number of columns in the grid.
 * @returns {Set<string>} A set of unique antinode positions in the form "row,col".
 */
const calculateAntinodes = (antennasByFreq, rows, cols) => {
  const antinodes = new Set();

  for (const freq in antennasByFreq) {
    const antennas = antennasByFreq[freq];
    if (antennas.length < 2) continue; // Need at least two antennas for antinodes

    for (let i = 0; i < antennas.length; i++) {
      for (let j = i + 1; j < antennas.length; j++) {
        const [Ax, Ay] = antennas[i];
        const [Bx, By] = antennas[j];
        const positions = computeAntinodePositions(Ax, Ay, Bx, By);

        for (const [x, y] of positions) {
          if (isWithinBounds(x, y, rows, cols)) {
            antinodes.add(`${x},${y}`);
          }
        }
      }
    }
  }

  return antinodes;
};

/**
 * Given the puzzle input, calculates how many unique locations within the map contain an antinode.
 * @param {string[]} inputLines - The puzzle input lines.
 * @returns {number} The number of unique antinode locations.
 */
const calculateUniqueLocations = (inputLines) => {
  const grid = parseGrid(inputLines);
  const rows = grid.length;
  const cols = grid[0].length;

  const antennasByFreq = findAntennasByFrequency(grid);
  const antinodes = calculateAntinodes(antennasByFreq, rows, cols);

  return antinodes.size;
};

const uniqueLocationsCount = calculateUniqueLocations(input);

console.log(uniqueLocationsCount.toLocaleString());
clipboard.writeSync(uniqueLocationsCount.toString());
